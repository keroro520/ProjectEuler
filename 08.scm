;; 找出序列中连续的5个数字, 使其乘积最大

;; 一开始我是把整个序列当作一个整数...好吧, 原以为Scheme是可以操作超大数的, 可是发现它把我的序列给截断了...再后来, AC后...发现不是Scheme截断的, 是我在网页上复制下来后没把换行符给去掉...Scheme确实是可以操作大数的...
;; 最后也写了把序列当作整数来处理的版本, largest-product-in-a-series_2

;; 接下来就把序列当作string来处理了. 
;; 用到的内置的string函数: (string-length s) 返回s的长度; (string-ref s index) 返回s[index]; 还用到了(char->integer ch)字符转整型

;; NOTE: 一开始复制的时候把换行符也给复制了. 这点要小心, 把换行符去掉!!!!

;; 思路: 暴力枚举
;;       其中a,b,c,d,e表当前的5个数

(define (largest-product-in-a-series n-string)
    (define len (string-length n-string))
    (define (char-to-integer s index)
        (- (char->integer (string-ref s index)) (char->integer #\0)))
    (define (help a b c d e result index)
        (if (= len index)
            result
            (let ((now (* a b c d e))
                  (f (char-to-integer n-string index)))
                 (if (< result now)
                     (help b c d e f now    (+ index 1))
                     (help b c d e f result (+ index 1))))))
    (help 0 0 0 0 0 0 0))

(define (largest-product-in-a-series_2 n)
    (define (help a b c d e result rest)
        (let ((now (* a b c d e))
              (f   (modulo rest 10))
              (new-rest (quotient rest 10)))
             (define new-result (if (< result now) now result))
             (if (= 0 rest)     ; 这个理论上必须放在这儿, 而不是放在最前面, 不解释
                 new-result
                 (help b c d e f new-result new-rest))))
    (help 0 0 0 0 0 0 n))
                
    

(define maxn-string
        "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450")

(define maxn
        7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450)



;; Tesing 
        (largest-product-in-a-series maxn-string)
        (largest-product-in-a-series_2 maxn)
